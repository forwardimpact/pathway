# yaml-language-server: $schema=https://www.forwardimpact.team/schema/json/capability.schema.json

name: Delivery
emojiIcon: ðŸš€
ordinalRank: 1
description: |
  Building and shipping solutions that solve real problems.
  Encompasses full-stack development, data integration, problem discovery,
  and rapid prototyping.
professionalResponsibilities:
  awareness:
    Complete assigned implementation tasks within established patterns with
    guidance from senior engineers
  foundational:
    Deliver small features end-to-end with minimal guidance, understanding how
    your code fits the broader system
  working:
    Own feature delivery from design through deployment, making sound technical
    trade-offs to ship value on time
  practitioner:
    Lead technical delivery of complex projects across multiple teams, unblock
    others through hands-on contributions, and ensure engineering quality
  expert:
    Drive delivery of the most critical technical initiatives, establish
    engineering delivery practices across the business unit, and be the
    technical authority on high-stakes projects
managementResponsibilities:
  awareness:
    Track team progress and communicate status to stakeholders with guidance
  foundational:
    Coordinate team delivery by managing dependencies, removing blockers, and
    keeping stakeholders informed
  working:
    Own team delivery outcomesâ€”balance scope, staffing, and timeline; make
    resourcing decisions to meet commitments
  practitioner:
    Drive delivery excellence across multiple teams, establish delivery metrics
    and practices for your area, hold teams accountable, and escalate cross-team
    risks
  expert:
    Shape delivery culture across the business unit, lead strategic delivery
    transformations, and represent delivery commitments at executive level
skills:
  - id: architecture_design
    name: Architecture & Design
    human:
      description:
        Ability to design software systems that are scalable, maintainable, and
        fit for purpose. In the AI era, this includes designing systems that
        effectively leverage AI capabilities while maintaining human oversight.
      levelDescriptions:
        awareness:
          You understand basic architectural concepts (separation of concerns,
          modularity, coupling) and can read architecture diagrams. You follow
          established patterns with guidance.
        foundational:
          You explain and apply common patterns (MVC, microservices,
          event-driven) to familiar problems. You contribute to design
          discussions and identify when existing patterns don't fit.
        working:
          You design components and services independently for moderate
          complexity. You make appropriate trade-off decisions, document design
          rationale, and consider AI integration points in your designs.
        practitioner:
          You design complex multi-component systems end-to-end, evaluate
          architectural options for large initiatives across teams, guide
          technical decisions for your area, and mentor engineers on
          architecture. You balance elegance with delivery needs.
        expert:
          You define architecture standards and patterns across the business
          unit. You innovate on approaches to large-scale challenges, shape
          AI-integrated system design, and are recognized externally as an
          architecture authority.
    agent:
      name: architecture-design
      description:
        Guide for designing software systems and making architectural decisions.
      useWhen: |
        Asked to design a system, evaluate architecture options, or make
        structural decisions about code organization.
      stages:
        specify:
          focus: |
            Define system requirements and constraints before design.
            Clarify functional and non-functional requirements.
          activities:
            - Document functional requirements and use cases
            - Identify non-functional requirements (scale, latency,
              availability)
            - Document system constraints and integration points
            - Identify stakeholders and their concerns
            - Mark ambiguities with [NEEDS CLARIFICATION]
          ready:
            - Functional requirements are documented
            - Non-functional requirements are specified
            - Constraints are identified
            - Stakeholder concerns are understood
        plan:
          focus: Understanding requirements and designing solutions
          activities:
            - Gather context about existing systems and constraints
            - Clarify non-functional requirements (scale, latency, availability)
            - Identify key decisions that are hard to change later
            - Evaluate trade-offs between architectural options
            - Document approach with rationale
          ready:
            - Requirements are clearly understood
            - Key decisions are documented with rationale
            - Trade-offs are explicit
            - Dependencies are identified
        code:
          focus: Implementing architecture faithfully while adapting to reality
          activities:
            - Verify implementation aligns with design decisions
            - Implement interfaces and boundaries before internals
            - Document any deviations from design with rationale
            - Keep architecture documentation in sync with implementation
          ready:
            - Implementation matches documented design
            - Deviations documented with rationale
            - Failure modes are considered and handled
            - Security implications are reviewed
        review:
          focus: Verifying architecture implementation and documentation
          activities:
            - Compare implementation to design documentation
            - Verify all decisions were followed or documented
            - Assess maintainability and extensibility
            - Ensure architecture enables future changes
          ready:
            - Design docs reflect actual implementation
            - Architecture decisions validated in practice
            - Scalability requirements addressed
        deploy:
          focus: |
            Deploy architecture and verify it performs as designed
            in production environment.
          activities:
            - Deploy system components to production
            - Verify architectural boundaries work under load
            - Monitor performance against requirements
            - Document any operational learnings
          ready:
            - System deployed successfully
            - Performance meets requirements
            - Monitoring confirms design assumptions
            - Operational procedures are documented
    implementationReference: |
      ## Common Patterns

      ### Service Architecture
      - **Microservices**: Independent deployment, clear boundaries
      - **Monolith**: Simpler deployment, easier refactoring
      - **Modular monolith**: Boundaries within single deployment

      ### Data Patterns
      - **Event sourcing**: Full audit trail, complex queries
      - **CQRS**: Separate read and write models
      - **Repository pattern**: Abstract data access

      ### Communication Patterns
      - **REST**: Synchronous, request-response
      - **Event-driven**: Asynchronous, loose coupling
      - **gRPC**: Efficient, strongly typed
  - id: full_stack_development
    name: Full-Stack Development
    human:
      description:
        Building complete solutions across frontend, APIs, databases, and
        infrastructure without dependencies on specialists. JavaScript and
        Python are our primary languages, with CloudFormation and Terraform for
        infrastructure. Essential for rapid delivery and embedded engineering
        work.
      levelDescriptions:
        awareness:
          You understand how frontend, backend, and database layers work
          together. You can make changes in one layer with guidance and
          understand the impact on other layers.
        foundational:
          You build simple features across frontend and backend using JavaScript
          or Python. You understand how layers connect through APIs and can
          debug across the stack.
        working:
          You deliver complete features end-to-end independentlyâ€”frontend,
          backend, database, and infrastructure (CloudFormation/Terraform). You
          make pragmatic technology choices and deploy what you build.
        practitioner:
          You build complete applications rapidly across any technology stack
          for teams in your area. You select the right tools for each problem,
          balance technical debt with delivery speed, and mentor engineers on
          full-stack development.
        expert:
          You work comfortably in any language and rapidly acquire new skills as
          needed. You deliver production solutions in days not months, shape
          full-stack practices across the business unit, and exemplify
          polymathic engineering.
    agent:
      name: full-stack-development
      description:
        Guide for building complete solutions across the full technology stack.
      useWhen: |
        Implementing features spanning frontend, backend, database, and
        infrastructure layers.
      stages:
        specify:
          focus: |
            Define full-stack feature requirements and acceptance criteria.
            Clarify user needs and system integration points.
          activities:
            - Identify user stories and acceptance criteria
            - Document expected user interactions
            - Clarify integration requirements with existing systems
            - Define non-functional requirements (performance, security)
            - Mark ambiguities with [NEEDS CLARIFICATION]
          ready:
            - User stories are documented
            - Acceptance criteria are defined
            - Integration points are identified
            - Non-functional requirements are clear
        plan:
          focus: Designing the complete solution across layers
          activities:
            - Define the API contract between frontend and backend
            - Design database schema to support the feature
            - Plan infrastructure requirements
            - Identify cross-layer dependencies
          ready:
            - API contract is defined
            - Database schema is designed
            - Infrastructure needs identified
            - Layer boundaries are clear
        code:
          focus: Building vertically across all layers
          activities:
            - Implement backend API endpoints
            - Build frontend components and integrate with API
            - Set up database migrations and queries
            - Configure infrastructure as code
            - Test across layer boundaries
          ready:
            - Frontend connects to backend correctly
            - Database schema supports the feature
            - Error handling spans all layers
            - Feature works end-to-end
        review:
          focus: Verifying integration across the stack
          activities:
            - Test complete user flows end-to-end
            - Verify error handling at each layer
            - Check deployment pipeline works
            - Validate monitoring and logging
          ready:
            - End-to-end tests pass
            - Deployment is automated
            - Cross-layer errors are handled gracefully
        deploy:
          focus: |
            Deploy full-stack feature to production and verify end-to-end
            functionality in live environment.
          activities:
            - Deploy backend services
            - Deploy frontend changes
            - Run database migrations
            - Verify feature works in production
            - Monitor for errors and performance issues
          ready:
            - All components deployed successfully
            - Feature works end-to-end in production
            - No errors in monitoring
            - Performance meets requirements
    toolReferences:
      - name: Terraform
        url: https://developer.hashicorp.com/terraform/docs
        simpleIcon: terraform
        description: Infrastructure as code tool
        useWhen: Provisioning and managing cloud infrastructure as code
      - name: CloudFormation
        url: https://docs.aws.amazon.com/cloudformation/
        description: AWS infrastructure as code service
        useWhen: Managing cloud infrastructure using declarative templates
      - name: Colima
        url: https://github.com/abiosoft/colima
        simpleIcon: docker
        description: Container runtime for macOS with Docker-compatible CLI
        useWhen:
          Running containers locally, building images, or containerizing
          applications
    implementationReference: |
      ## Technology Stack

      ### Primary Languages
      - **JavaScript/TypeScript**: Frontend and Node.js backend
      - **Python**: Backend APIs and data processing

      ### Infrastructure
      - **Terraform**: Cloud infrastructure as code
      - **CloudFormation**: AWS-specific infrastructure
      - **Docker**: Containerization

      ## Layer Responsibilities

      | Layer | Responsibilities |
      |-------|-----------------|
      | Frontend | UI/UX, client validation, API integration |
      | Backend | Business logic, auth, external services |
      | Database | Persistence, queries, migrations |
      | Infrastructure | Deployment, scaling, monitoring |
