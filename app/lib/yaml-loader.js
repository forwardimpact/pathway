/**
 * Browser-compatible YAML loading
 *
 * Uses _index.yaml files to discover files in directory structures.
 * These index files are auto-generated by the CLI (npx pathway --generate-index).
 */

import { parse as parseYaml } from "https://cdn.jsdelivr.net/npm/yaml@2.3.4/+esm";

/**
 * Load and parse a YAML file
 * @param {string} path - Path to the YAML file
 * @returns {Promise<*>}
 */
export async function loadYamlFile(path) {
  const response = await fetch(path);
  if (!response.ok) {
    throw new Error(
      `Failed to load ${path}: ${response.status} ${response.statusText}`,
    );
  }
  const text = await response.text();
  return parseYaml(text);
}

/**
 * Try to load a YAML file, return null if not found
 * @param {string} path - Path to the YAML file
 * @returns {Promise<*|null>}
 */
async function tryLoadYamlFile(path) {
  const response = await fetch(path);
  if (response.status === 404) {
    return null;
  }
  if (!response.ok) {
    throw new Error(
      `Failed to load ${path}: ${response.status} ${response.statusText}`,
    );
  }
  const text = await response.text();
  return parseYaml(text);
}

/**
 * Load directory index (list of file IDs)
 * @param {string} dir - Directory path
 * @returns {Promise<string[]>} Array of file IDs
 */
async function loadDirIndex(dir) {
  const index = await loadYamlFile(`${dir}/_index.yaml`);
  return index.files || [];
}

/**
 * Load skills from capability files
 * Skills are embedded in capability YAML files under the 'skills' array.
 * This function extracts all skills and adds the capability ID back to each.
 * @param {string} capabilitiesDir - Path to capabilities directory
 * @returns {Promise<Array>} Array of skill objects
 */
async function loadSkillsFromCapabilities(capabilitiesDir) {
  const capabilityIds = await loadDirIndex(capabilitiesDir);
  const allSkills = [];

  for (const capabilityId of capabilityIds) {
    const capability = await loadYamlFile(
      `${capabilitiesDir}/${capabilityId}.yaml`,
    );

    if (capability.skills && Array.isArray(capability.skills)) {
      for (const skill of capability.skills) {
        const { id, name, isHumanOnly, human, agent } = skill;
        allSkills.push({
          id,
          name,
          capability: capabilityId, // Add capability from parent
          description: human.description,
          levelDescriptions: human.levelDescriptions,
          // Include isHumanOnly flag for agent filtering (defaults to false)
          ...(isHumanOnly && { isHumanOnly }),
          ...(agent && { agent }),
        });
      }
    }
  }

  return allSkills;
}

/**
 * Load disciplines from directory using _index.yaml
 * @param {string} disciplinesDir - Path to disciplines directory
 * @returns {Promise<Array>} Array of discipline objects
 */
async function loadDisciplinesFromDir(disciplinesDir) {
  const disciplineIds = await loadDirIndex(disciplinesDir);

  const disciplines = await Promise.all(
    disciplineIds.map(async (id) => {
      const content = await loadYamlFile(`${disciplinesDir}/${id}.yaml`);
      // Shared content at top level, role summaries under human:
      const {
        specialization,
        roleTitle,
        // Shared content - now at root level
        description,
        // Structural properties (derivation inputs)
        coreSkills,
        supportingSkills,
        broadSkills,
        behaviourModifiers,
        // Presentation sections
        human,
        agent,
      } = content;
      return {
        id,
        specialization,
        roleTitle,
        // Shared content at top level
        description,
        // Structural properties
        coreSkills,
        supportingSkills,
        broadSkills,
        behaviourModifiers,
        // Human presentation content (role summaries only)
        ...human,
        ...(agent && { agent }),
      };
    }),
  );
  return disciplines;
}

/**
 * Load tracks from directory using _index.yaml
 * @param {string} tracksDir - Path to tracks directory
 * @returns {Promise<Array>} Array of track objects
 */
async function loadTracksFromDir(tracksDir) {
  const trackIds = await loadDirIndex(tracksDir);

  const tracks = await Promise.all(
    trackIds.map(async (id) => {
      const content = await loadYamlFile(`${tracksDir}/${id}.yaml`);
      // Shared content at top level (no human section for tracks anymore)
      const {
        name,
        // Shared content - now at root level
        description,
        roleContext,
        // Structural properties (derivation inputs)
        isProfessional,
        isManagement,
        skillModifiers,
        behaviourModifiers,
        matchingWeights,
        validDisciplines,
        // Agent section (no human section anymore for tracks)
        agent,
      } = content;
      return {
        id,
        name,
        // Shared content at top level
        description,
        roleContext,
        // Structural properties
        isProfessional,
        isManagement,
        skillModifiers,
        behaviourModifiers,
        matchingWeights,
        validDisciplines,
        ...(agent && { agent }),
      };
    }),
  );
  return tracks;
}

/**
 * Load behaviours from directory using _index.yaml
 * @param {string} behavioursDir - Path to behaviours directory
 * @returns {Promise<Array>} Array of behaviour objects
 */
async function loadBehavioursFromDir(behavioursDir) {
  const behaviourIds = await loadDirIndex(behavioursDir);

  const behaviours = await Promise.all(
    behaviourIds.map(async (id) => {
      const content = await loadYamlFile(`${behavioursDir}/${id}.yaml`);
      // Flatten human properties to top level (behaviours use human: section in YAML)
      const { name, human, agent } = content;
      return {
        id,
        name,
        ...human,
        ...(agent && { agent }),
      };
    }),
  );
  return behaviours;
}

/**
 * Load capabilities from directory using _index.yaml
 * @param {string} capabilitiesDir - Path to capabilities directory
 * @returns {Promise<Array>} Array of capability objects
 */
async function loadCapabilitiesFromDir(capabilitiesDir) {
  const capabilityIds = await loadDirIndex(capabilitiesDir);

  const capabilities = await Promise.all(
    capabilityIds.map((id) => loadYamlFile(`${capabilitiesDir}/${id}.yaml`)),
  );
  return capabilities;
}

/**
 * Load questions from folder structure using skill/behaviour IDs
 * @param {string} questionsDir - Path to questions directory
 * @param {Array} skills - Skills array (with id property)
 * @param {Array} behaviours - Behaviours array (with id property)
 * @returns {Promise<Object>}
 */
async function loadQuestionFolder(questionsDir, skills, behaviours) {
  const [skillEntries, behaviourEntries] = await Promise.all([
    Promise.all(
      skills.map(async (skill) => {
        const content = await tryLoadYamlFile(
          `${questionsDir}/skills/${skill.id}.yaml`,
        );
        return [skill.id, content || {}];
      }),
    ),
    Promise.all(
      behaviours.map(async (behaviour) => {
        const content = await tryLoadYamlFile(
          `${questionsDir}/behaviours/${behaviour.id}.yaml`,
        );
        return [behaviour.id, content || {}];
      }),
    ),
  ]);

  return {
    skillLevels: Object.fromEntries(skillEntries),
    behaviourMaturities: Object.fromEntries(behaviourEntries),
  };
}

/**
 * Load all data files
 * @param {string} [dataDir='./data'] - Path to data directory
 * @returns {Promise<Object>}
 */
export async function loadAllData(dataDir = "./data") {
  // Load capabilities first (skills are embedded in capabilities)
  const capabilities = await loadCapabilitiesFromDir(`${dataDir}/capabilities`);

  // Extract skills from capabilities
  const skills = await loadSkillsFromCapabilities(`${dataDir}/capabilities`);

  // Load remaining core data in parallel (using _index.yaml for discovery)
  const [drivers, behaviours, disciplines, tracks, grades, stages, framework] =
    await Promise.all([
      loadYamlFile(`${dataDir}/drivers.yaml`),
      loadBehavioursFromDir(`${dataDir}/behaviours`),
      loadDisciplinesFromDir(`${dataDir}/disciplines`),
      loadTracksFromDir(`${dataDir}/tracks`),
      loadYamlFile(`${dataDir}/grades.yaml`),
      loadYamlFile(`${dataDir}/stages.yaml`),
      loadYamlFile(`${dataDir}/framework.yaml`),
    ]);

  // Load questions using skill/behaviour IDs
  const questions = await loadQuestionFolder(
    `${dataDir}/questions`,
    skills,
    behaviours,
  );

  return {
    drivers,
    behaviours,
    skills,
    disciplines,
    tracks,
    grades,
    questions,
    capabilities,
    stages,
    framework,
  };
}

/**
 * Load agent-specific data for browser-based agent generation
 * Uses co-located files where agent sections are embedded in entity files
 * @param {string} [dataDir='./data'] - Path to data directory
 * @returns {Promise<Object>} Agent data including disciplines, tracks, behaviours, vscodeSettings, devcontainer, copilotSetupSteps
 */
export async function loadAgentDataBrowser(dataDir = "./data") {
  const [
    disciplines,
    tracks,
    behaviours,
    vscodeSettings,
    devcontainer,
    copilotSetupSteps,
  ] = await Promise.all([
    loadDisciplinesFromDir(`${dataDir}/disciplines`),
    loadTracksFromDir(`${dataDir}/tracks`),
    loadBehavioursFromDir(`${dataDir}/behaviours`),
    tryLoadYamlFile(`${dataDir}/vscode-settings.yaml`),
    tryLoadYamlFile(`${dataDir}/devcontainer.yaml`),
    tryLoadYamlFile(`${dataDir}/copilot-setup-steps.yaml`),
  ]);

  // Extract agent sections from co-located files
  return {
    disciplines: disciplines
      .filter((d) => d.agent)
      .map((d) => ({ id: d.id, ...d.agent })),
    tracks: tracks
      .filter((t) => t.agent)
      .map((t) => ({ id: t.id, ...t.agent })),
    behaviours: behaviours
      .filter((b) => b.agent)
      .map((b) => ({ id: b.id, ...b.agent })),
    vscodeSettings: vscodeSettings || {},
    devcontainer: devcontainer || {},
    copilotSetupSteps: copilotSetupSteps || null,
  };
}
